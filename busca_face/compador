from deepface import DeepFace
import os
import re
import shutil
import tempfile
import uuid
import string

def criar_nome_seguro(nome_original):
    """Cria um nome de arquivo seguro removendo TODOS os caracteres n√£o-ASCII"""
    # Extrai a extens√£o do arquivo
    nome, extensao = os.path.splitext(nome_original)
    
    # Remove todos os caracteres n√£o-ASCII e mant√©m apenas caracteres seguros
    nome_seguro = ''.join(
        c for c in nome 
        if c in string.ascii_letters or c in string.digits or c in ' _-'
    )
    
    # Substitui espa√ßos por underscores
    nome_seguro = re.sub(r'\s+', '_', nome_seguro)
    
    # Remove underscores m√∫ltiplos
    nome_seguro = re.sub(r'_{2,}', '_', nome_seguro)
    
    # Remove underscores no in√≠cio e fim
    nome_seguro = nome_seguro.strip('_')
    
    # Se o nome ficou vazio, gera um nome √∫nico
    if not nome_seguro:
        nome_seguro = f"file_{uuid.uuid4().hex[:8]}"
    
    # Garante que a extens√£o √© v√°lida
    extensoes_validas = ['.jpg', '.jpeg', '.png', '.bmp', '.gif']
    extensao = extensao.lower()
    if extensao not in extensoes_validas:
        extensao = '.jpg'  # Usa .jpg como padr√£o
    
    return f"{nome_seguro}{extensao}"

def criar_copia_temporaria(pasta_origem):
    """Cria uma c√≥pia tempor√°ria da pasta com nomes de arquivos 100% v√°lidos"""
    temp_dir = tempfile.mkdtemp()
    mapeamento = {}
    
    for nome_arquivo in os.listdir(pasta_origem):
        caminho_original = os.path.join(pasta_origem, nome_arquivo)
        
        # Ignora se n√£o for arquivo ou n√£o for imagem
        if not os.path.isfile(caminho_original):
            continue
            
        extensao = os.path.splitext(nome_arquivo)[1].lower()
        if extensao not in ['.jpg', '.jpeg', '.png', '.bmp', '.gif']:
            continue
        
        # Gera nome seguro 100% ASCII
        nome_seguro = criar_nome_seguro(nome_arquivo)
        
        # Garante que n√£o haver√° conflito de nomes
        contador = 1
        nome_base, ext = os.path.splitext(nome_seguro)
        while os.path.exists(os.path.join(temp_dir, nome_seguro)):
            nome_seguro = f"{nome_base}_{contador}{ext}"
            contador += 1
        
        # Copia o arquivo
        caminho_temp = os.path.join(temp_dir, nome_seguro)
        shutil.copy2(caminho_original, caminho_temp)
        
        # Armazena o mapeamento
        mapeamento[nome_seguro] = nome_arquivo
    
    return temp_dir, mapeamento

# Caminho da imagem de refer√™ncia
imagem_ref = r"C:\Users\luzo.neto\Downloads\duda_its.JPG"

# Pasta com todas as imagens onde procurar
pasta_busca = r"D:\Users\luzo.neto\Downloads\fotos_perfil"

# Verifica exist√™ncia dos caminhos
if not os.path.exists(imagem_ref):
    print(f"Erro: Imagem de refer√™ncia '{imagem_ref}' n√£o encontrada.")
    exit()

if not os.path.exists(pasta_busca):
    print(f"Erro: Pasta '{pasta_busca}' n√£o encontrada.")
    exit()

# Cria uma c√≥pia tempor√°ria com nomes de arquivos v√°lidos
print("üîÑ Criando c√≥pia tempor√°ria com nomes de arquivos 100% v√°lidos...")
pasta_temp, mapeamento = criar_copia_temporaria(pasta_busca)

try:
    # Buscar rostos semelhantes na c√≥pia tempor√°ria
    print("üîç Buscando rostos semelhantes...")
    resultados = DeepFace.find(
        img_path=imagem_ref,
        db_path=pasta_temp,
        detector_backend="opencv",
        model_name="ArcFace",
        distance_metric="cosine",
        enforce_detection=False,
        threshold=0.65
    )

    # Mostrar resultados com nomes originais
    if len(resultados) > 0 and not resultados[0].empty:
        print("\n‚úÖ Rostos encontrados:")
        for idx, linha in resultados[0].iterrows():
            nome_temp = os.path.basename(linha['identity'])
            nome_original = mapeamento.get(nome_temp, nome_temp)
            
            similaridade = 1 - linha['distance']
            print(f"{nome_original} ‚Üí {similaridade:.2%} de similaridade")
    else:
        print("‚ùå Nenhum rosto semelhante encontrado.")

except Exception as e:
    print(f"Erro durante a busca: {e}")

finally:
    # Limpa a pasta tempor√°ria
    try:
        shutil.rmtree(pasta_temp)
        print(f"üßπ Pasta tempor√°ria {pasta_temp} removida.")
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao remover pasta tempor√°ria: {e}")
